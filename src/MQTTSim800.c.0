/*
 * MQTTSim800.c
 *
 */
#include <stdlib.h>
#include <string.h>

#include "MQTTSim800.h"
#include "main.h"
#include "adc.h"
#include "usart_arch.h"
#include "isens.h"
#include "gsm.h"
#include "MQTTPacket.h"
#include "logger.h"


extern uint16_t logRdBufFill;

uint8_t tx_buffer[256] = {0};

//uint8_t rx_data = 0;
//uint8_t rx_buffer[1460] = {0};
uint16_t rx_index = 0;

uint8_t mqtt_receive = 0;
char mqtt_buffer[1460] = {0};
uint16_t mqtt_index = 0;

FlagStatus mqttSubFlag = RESET;
FlagStatus mqttPubFlag = RESET;

struct timer_list mqttPubTimer;

void mqttConnectCb( FlagStatus conn );

void mqttPubTout( uintptr_t arg ){
  (void)arg;

  if( SIM800.mqttServer.mqttconn == 1 ) {
    mqttPubFlag = SET;
  }
}


//void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
//  if (huart == UART_SIM800) {
//    Sim800_RxCallBack();
//  }
//  HAL_UART_Receive_IT(UART_SIM800, &rx_data, 1);
//}


//void simRxProcess( char * rxbuf, uint32_t size ) {
//  if (SIM800.mqttServer.connect == 0) {
//    if( size == 2) {
//      return;
//    }
//    else {
//      memcpy(mqtt_buffer, rxbuf, size);
//      clearRxBuffer( rxbuf, size );
//      if( strstr(mqtt_buffer, "DY CONNECT\r\n") || strstr(mqtt_buffer, "CONNECT\r\n") ) {
//        // Есть соединение с MQTT-сервером
//        SIM800.mqttServer.connect = 1;
//        mqttConnectCb( SIM800.mqttServer.connect );
//      }
//    }
//  }
//
//  if (strstr( rxbuf, "CLOSED\r\n")
//      || strstr( rxbuf, "ERROR\r\n")
//      || strstr( rxbuf, "DEACT\r\n"))
//  {
//    // Нет соединения с MQTT-сервером
//    SIM800.mqttServer.connect = 0;
//    mqttConnectCb( SIM800.mqttServer.connect );
//  }
//
//  if (SIM800.mqttServer.connect == 1 && size == 48) {
//    mqtt_receive = 1;
//  }
//  if (mqtt_receive == 1) {
//    mqtt_buffer[mqtt_index++] = rx_data;
//    if (mqtt_index > 1 && mqtt_index - 1 > mqtt_buffer[1]) {
//      MQTT_Receive((unsigned char *)mqtt_buffer);
//      clearRxBuffer();
//      clearMqttBuffer();
//    }
//    if (mqtt_index >= sizeof(mqtt_buffer)) {
//      clearMqttBuffer();
//    }
//  }
//  if (rx_index >= sizeof(mqtt_buffer)) {
//    clearRxBuffer();
//    clearMqttBuffer();
//  }
//}


/**
 * Clear SIM800 UART RX buffer.
 * @param NONE
 * @return NONE
 */
void clearRxBuffer( char * buf, uint32_t * size ){
  memset( buf, 0, *size );
  *size = 0;
}

/**
 * Clear MQTT buffer.
 * @param NONE
 * @return NONE
 */
void clearMqttBuffer(void) {
  mqtt_receive = 0;
  mqtt_index = 0;
  memset(mqtt_buffer, 0, sizeof(mqtt_buffer));
}

/**
 * Send AT command to SIM800 over UART.
 * @param command the command to be used the send AT command
 * @param reply to be used to set the correct answer to the command
 * @param delay to be used to the set pause to the reply
 * @return error, 0 is OK
 */
int SIM800_SendCommand(char *command, char *reply, uint16_t delay){
  uint32_t tmptick;
  tmptick = mTick + delay;
  uint8_t rc = 1;
  uint16_t size;

  *mqtt_buffer = '\0';
  simHnd.txh->data = (uint8_t*)command;
  size = (uint16_t)strlen(command);
  if( uartTransmit(simHnd.txh, size, 1000) != size ){
    trace_puts( "uart err" );
  }

  if( reply == NULL ){
    mDelay(delay);
    return 0;
  }

  while( tmptick >= mTick ) {
    if( strstr(mqtt_buffer, reply) != NULL ) {
      rc = 0;
      break;
    }
  }
  // Подготовим буфер для приема
  clearRxBuffer( (char *)(simHnd.rxh->rxFrame), &(simHnd.rxh->frame_offset) );
  return rc;
}


/**
 * Deinitialization SIM800.
 * @param NONE
 * @return error status, 0 - OK
 */
int MQTT_Deinit(void) {
    int error = 0;

    const char * cmd = "+++\r\n";

    mDelay(1000);
    simHnd.txh->data = (uint8_t*)cmd;
    if( uartTransmit(simHnd.txh, 5, 1000) != 5 ){
      trace_puts( "uart err" );
    }

    mDelay(1000);

    SIM800_SendCommand("ATE1\r\n", "OK\r\n", CMD_DELAY_2);

    error += SIM800_SendCommand("AT+CGATT=0\r\n", "OK\r\n", CMD_DELAY_5);
    error += SIM800_SendCommand("AT+CIPSHUT\r\n", "SHUT OK\r\n", CMD_DELAY_5);
    SIM800.mqttServer.mqttconn = 0;
    SIM800.mqttServer.tcpconn = 0;
    return error;
}


/**
 * initialization SIM800.
 * @param NONE
 * @return error status, 0 - OK
 */
void mqttInit(void) {
  SIM800.mqttServer.mqttconn = 0;
  SIM800.mqttServer.tcpconn = 0;
//    char str[32] = {0};

    // MQQT settings
    SIM800.sim.apn = "internet";
    SIM800.sim.apn_user = "";
    SIM800.sim.apn_pass = "";
    SIM800.mqttServer.host = "test.mosquitto.org";
    SIM800.mqttServer.port = 1883;
    SIM800.mqttClient.username = "";
    SIM800.mqttClient.pass = "";
    SIM800.mqttClient.clientID = "";
    SIM800.mqttClient.keepAliveInterval = 60;

    timerSetup( &mqttPubTimer, mqttPubTout, (uintptr_t)NULL );
}


/**
 * Starting MQTT process.
 * @param NONE
 * @return error status, 0 - OK
 */
int mqttStart(void) {
    return SIM800_SendCommand("AT+CIPMODE=1\r\n", "OK\r\n", CMD_DELAY_2);
}


/**
 * Connect to MQTT server in Internet over TCP.
 * @param NONE
 * @return NONE
 */
void MQTT_Connect(void)
{
    SIM800.mqttReceive.newEvent = 0;
    SIM800.mqttServer.tcpconn = 0;
    char str[128] = {0};
    unsigned char buf[128] = {0};
    sprintf(str, "AT+CIPSTART=\"TCP\",\"%s\",%d\r\n", SIM800.mqttServer.host, SIM800.mqttServer.port);
    SIM800_SendCommand(str, "CONNECT\r\n", CMD_DELAY_10*30 );
    mDelay(1000);
    if (SIM800.mqttServer.tcpconn == 1)
    {
        MQTTPacket_connectData datas = MQTTPacket_connectData_initializer;
        datas.username.cstring = SIM800.mqttClient.username;
        datas.password.cstring = SIM800.mqttClient.pass;
        datas.clientID.cstring = SIM800.mqttClient.clientID;
        datas.keepAliveInterval = SIM800.mqttClient.keepAliveInterval;
        datas.cleansession = 1;
        int mqtt_len = MQTTSerialize_connect(buf, sizeof(buf), &datas);
        simHnd.txh->data = buf;
        uartTransmit( simHnd.txh, mqtt_len, TOUT_100 );
        mDelay(5000);
    }
}

/**
 * Public on the MQTT broker of the message in a topic
 * @param topic to be used to the set topic
 * @param payload to be used to the set message for topic
 * @return NONE
 */
void MQTT_Pub(char *topic, char *payload)
{
    unsigned char buf[256] = {0};

    MQTTString topicString = MQTTString_initializer;
    topicString.cstring = topic;

    int mqtt_len = MQTTSerialize_publish(buf, sizeof(buf), 0, 0, 0, 0,
                                         topicString, (unsigned char *)payload, (int)strlen(payload));
    simHnd.txh->data = buf;
    uartTransmit( simHnd.txh, mqtt_len, TOUT_100 );
    mDelay(100);
}

/**
 * Public on the MQTT broker of the message in a topic
 * @param topic (uint8_t)  to be used to the set topic
 * @param payload to be used to the set message for topic
 * @return NONE
 */
void MQTT_PubUint8(char *topic, uint8_t payload)
{
    char str[32] = {0};
    sprintf(str, "%u", payload);
    MQTT_Pub(topic, str);
}

/**
 * Public on the MQTT broker of the message in a topic
 * @param topic (uint16_t)  to be used to the set topic
 * @param payload to be used to the set message for topic
 * @return NONE
 */
void MQTT_PubUint16(char *topic, uint16_t payload)
{
    char str[32] = {0};
    sprintf(str, "%u", payload);
    MQTT_Pub(topic, str);
}

/**
 * Public on the MQTT broker of the message in a topic
 * @param topic (uint32_t)  to be used to the set topic
 * @param payload to be used to the set message for topic
 * @return NONE
 */
void MQTT_PubUint32(char *topic, uint32_t payload)
{
    char str[32] = {0};
    sprintf(str, "%lu", payload);
    MQTT_Pub(topic, str);
}

/**
 * Public on the MQTT broker of the message in a topic
 * @param topic (float)  to be used to the set topic
 * @param payload to be used to the set message for topic
 * @return NONE
 */
void MQTT_PubFloat(char *topic, float payload)
{
    char str[32] = {0};
    sprintf(str, "%f", payload);
    MQTT_Pub(topic, str);
}

/**
 * Public on the MQTT broker of the message in a topic
 * @param topic (double)  to be used to the set topic
 * @param payload to be used to the set message for topic
 * @return NONE
 */
void MQTT_PubDouble(char *topic, double payload)
{
    char str[32] = {0};
    sprintf(str, "%f", payload);
    MQTT_Pub(topic, str);
}

/**
 * Send a PINGREQ to the MQTT broker (active session)
 * @param NONE
 * @return NONE
 */
void MQTT_PingReq(void)
{
    unsigned char buf[16] = {0};

    int mqtt_len = MQTTSerialize_pingreq(buf, sizeof(buf));
    simHnd.txh->data = buf;
    uartTransmit( simHnd.txh, mqtt_len, TOUT_100 );
}

/**
 * Subscribe on the MQTT broker of the message in a topic
 * @param topic to be used to the set topic
 * @return NONE
 */
void MQTT_Sub(char *topic)
{
    unsigned char buf[256] = {0};

    MQTTString topicString = MQTTString_initializer;
    topicString.cstring = topic;

    int mqtt_len = MQTTSerialize_subscribe(buf, sizeof(buf), 0, 1, 1,
                                           &topicString, 0);
    simHnd.txh->data = buf;
    uartTransmit( simHnd.txh, mqtt_len, TOUT_100 );
    mDelay(100);
}

/**
 * Receive message from MQTT broker
 * @param receive mqtt bufer
 * @return NONE
 */
void MQTT_Receive(unsigned char *buf)
{
    memset(SIM800.mqttReceive.topic, 0, sizeof(SIM800.mqttReceive.topic));
    memset(SIM800.mqttReceive.payload, 0, sizeof(SIM800.mqttReceive.payload));
    MQTTString receivedTopic;
    unsigned char *payload;
    MQTTDeserialize_publish(&SIM800.mqttReceive.dup, &SIM800.mqttReceive.qos, &SIM800.mqttReceive.retained,
                            &SIM800.mqttReceive.msgId,
                            &receivedTopic, &payload, &SIM800.mqttReceive.payloadLen, buf,
                            sizeof(buf));
    memcpy(SIM800.mqttReceive.topic, receivedTopic.lenstring.data, receivedTopic.lenstring.len);
    SIM800.mqttReceive.topicLen = receivedTopic.lenstring.len;
    memcpy(SIM800.mqttReceive.payload, payload, SIM800.mqttReceive.payloadLen);
    SIM800.mqttReceive.newEvent = 1;
}

void mqttConnectCb( FlagStatus conn ){
  if( conn ){
    mqttSubFlag = SET;
    ledOff( LED_R, 0 );
  }
  else {
    mqttPubFlag = RESET;
    mqttSubFlag = RESET;
    // Две вспышки оранжевого цвета с интервалом в 3 сек
    ledToggleSet( LED_R, LED_BLINK_ON_TOUT, LED_SLOW_TOGGLE_TOUT, TOUT_3000, 2);
    ledToggleSet( LED_G, LED_BLINK_ON_TOUT, LED_SLOW_TOGGLE_TOUT, TOUT_3000, 2);
  }
}


void mqttProcess( void ){

  if(gsmState < GSM_WORK){
    return;
  }

  if( mqttPubFlag ) {
    mqttPubFlag = RESET;
  //    MQTT_Pub( "imei/test/string", "String message" );
  //    MQTT_PubUint8( "imei/test/uint8", pub_uint8 );
  //    MQTT_PubUint16( "imei/test/uint16", pub_uint16 );
  //    MQTT_PubUint32( "imei/test/uint32", pub_uint32 );
  //    MQTT_PubFloat( "imei/test/float", pub_float );
  //    MQTT_PubDouble( "imei/test/double", pub_double );
    if( iSens[ISENS_1].isensFlag ){
      char str[64];
      uint32_t ut = getRtcTime();

      sprintf( str, "{\"state\":[{time\":%ul,\"pls\":%ul}]}", (unsigned int)ut, (unsigned int)iSens[ISENS_1].isensCount );
      MQTT_Pub( "imei/i/1", str );
      iSens[ISENS_1].isensFlag = RESET;
    }
    else {
      // Считываем из ЛОГа
      if( logRdBufFill == 0 ){
        logQueryProcess();
      }
      if( logRdBufFill ){
        for( uint8_t i = 0; i < logRdBufFill; i++ ){
          char str[64];
          sLogRec * logrec = &(logRdBuf[i]);

          sprintf( str, "{\"arx\":[{time\":%ul,\"pls\":%ul}]}", (unsigned int)logrec->utime, (unsigned int)logrec->data );
          MQTT_Pub( "imei/i/1", str );
          logRdBufFill = 0;
        }
      }
      else {
        char str[64];
        int tu, td;
        uint32_t ut = getRtcTime();

        tu = adcHandle.adcVbat / 1000;
        td = adcHandle.adcVbat - (tu * 1000);
        if( td < 0 ){
          td = -td;
        }
        sprintf( str, "{\"time\":%ul,\"volt\":%d.%d}", (unsigned int)ut, tu, td );
        MQTT_Pub( "imei/volt", str );

        tu = adcHandle.adcTemp / 10;
        td = adcHandle.adcTemp - (tu * 10);
        if( td < 0 ){
          td = -td;
        }
        sprintf( str, "{\"time\":%ul,\"temp\":%d.%d}", (unsigned int)ut, tu, td );
        MQTT_Pub( "imei/temp", str );
      }
    }
    timerMod( &mqttPubTimer, MQTT_PUB_TOUT );

    if( SIM800.mqttReceive.newEvent ){
      unsigned char *topic = SIM800.mqttReceive.topic;
      int payload = atoi( (char*)SIM800.mqttReceive.payload );
      SIM800.mqttReceive.newEvent = 0;
      trace_printf( "mqttReceive: %s: %d\n", topic, payload );
    }
  }
}
